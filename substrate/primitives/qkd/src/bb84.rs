//! BB84 quantum key distribution protocol implementation.

use crate::entropy::EntropySource;
use crate::key_store::KeyStore;
use crate::error::{Error, Result};
use std::sync::Arc;

/// State of a BB84 protocol session.
#[derive(Debug)]
pub struct BB84Session {
    /// Session identifier.
    pub id: u64,
    /// Current state of the protocol.
    pub state: BB84State,
    /// Raw bits generated by the sender.
    pub raw_bits: Vec<u8>,
    /// Bases used for encoding/measuring.
    pub bases: Vec<u8>,
    /// Matched key positions after basis reconciliation.
    pub matched_positions: Vec<usize>,
    /// Error rate estimated during reconciliation.
    pub error_rate: f64,
    /// Final key after error correction and privacy amplification.
    pub final_key: Vec<u8>,
}

/// Internal state of the BB84 protocol.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum BB84State {
    /// Initial state.
    New,
    /// Quantum bits have been transmitted.
    BitsTransmitted,
    /// Bases have been reconciled.
    BasesReconciled,
    /// Error detection has been performed.
    ErrorDetected,
    /// Privacy amplification has been applied.
    PrivacyAmplified,
    /// Final key has been established.
    KeyEstablished,
    /// Error occurred during the protocol.
    Error,
}

/// Implementation of the BB84 quantum key distribution protocol.
pub struct BB84Protocol {
    /// Entropy source for quantum randomness.
    entropy_source: Arc<dyn EntropySource>,
    /// Key store for managing quantum keys.
    key_store: Arc<dyn KeyStore>,
}

impl BB84Protocol {
    /// Create a new BB84 protocol instance.
    pub fn new(
        entropy_source: Arc<dyn EntropySource>,
        key_store: Arc<dyn KeyStore>,
    ) -> Self {
        Self {
            entropy_source,
            key_store,
        }
    }

    /// Initialize a new BB84 session.
    pub async fn new_session(&self) -> Result<BB84Session> {
        let id = self.entropy_source.random_u64().await?;
        
        Ok(BB84Session {
            id,
            state: BB84State::New,
            raw_bits: Vec::new(),
            bases: Vec::new(),
            matched_positions: Vec::new(),
            error_rate: 0.0,
            final_key: Vec::new(),
        })
    }

    /// Generate quantum bits for transmission.
    pub async fn generate_quantum_bits(&self, session: &mut BB84Session, bit_count: usize) -> Result<Vec<u8>> {
        if session.state != BB84State::New {
            session.state = BB84State::Error;
            return Err(Error::Protocol("Invalid session state".to_string()));
        }

        // Generate random bits and bases
        session.raw_bits = self.entropy_source.random_bytes(bit_count).await?;
        session.bases = self.entropy_source.random_bytes(bit_count).await?;
        session.state = BB84State::BitsTransmitted;
        
        // In a real implementation, this would interact with quantum hardware
        // For now, return the classical representation of the quantum state
        Ok(session.raw_bits.clone())
    }

    /// Process received quantum bits.
    pub async fn process_received_bits(
        &self, 
        session: &mut BB84Session,
        received_bits: &[u8],
        measurement_bases: &[u8],
    ) -> Result<()> {
        if session.state != BB84State::New {
            session.state = BB84State::Error;
            return Err(Error::Protocol("Invalid session state".to_string()));
        }

        // Store the bits and bases
        session.raw_bits = received_bits.to_vec();
        session.bases = measurement_bases.to_vec();
        session.state = BB84State::BitsTransmitted;
        
        Ok(())
    }

    /// Perform basis reconciliation.
    pub async fn reconcile_bases(
        &self,
        session: &mut BB84Session,
        other_bases: &[u8],
    ) -> Result<Vec<usize>> {
        if session.state != BB84State::BitsTransmitted {
            session.state = BB84State::Error;
            return Err(Error::Protocol("Invalid session state".to_string()));
        }

        // Find where bases match
        let mut matched = Vec::new();
        for i in 0..session.bases.len().min(other_bases.len()) {
            if session.bases[i] == other_bases[i] {
                matched.push(i);
            }
        }

        session.matched_positions = matched.clone();
        session.state = BB84State::BasesReconciled;
        
        Ok(matched)
    }

    /// Perform error detection.
    pub async fn detect_errors(
        &self,
        session: &mut BB84Session,
        sample_bits: &[(usize, u8)],
    ) -> Result<f64> {
        if session.state != BB84State::BasesReconciled {
            session.state = BB84State::Error;
            return Err(Error::Protocol("Invalid session state".to_string()));
        }

        let mut error_count = 0;
        let sample_size = sample_bits.len();

        // Compare bits at sample positions
        for (pos, bit) in sample_bits {
            if *pos < session.raw_bits.len() && session.raw_bits[*pos] != *bit {
                error_count += 1;
            }
        }

        let error_rate = if sample_size > 0 {
            error_count as f64 / sample_size as f64
        } else {
            0.0
        };

        session.error_rate = error_rate;
        session.state = BB84State::ErrorDetected;
        
        Ok(error_rate)
    }

    /// Perform privacy amplification and generate final key.
    pub async fn privacy_amplification(
        &self,
        session: &mut BB84Session,
        final_length: usize,
    ) -> Result<Vec<u8>> {
        if session.state != BB84State::ErrorDetected {
            session.state = BB84State::Error;
            return Err(Error::Protocol("Invalid session state".to_string()));
        }

        // Extract sifted key from matched positions
        let mut sifted_key = Vec::with_capacity(session.matched_positions.len());
        for &pos in &session.matched_positions {
            if pos < session.raw_bits.len() {
                sifted_key.push(session.raw_bits[pos]);
            }
        }

        // In a real implementation, this would apply privacy amplification
        // For this example, we'll just truncate to the desired length
        let final_key = if sifted_key.len() > final_length {
            sifted_key[0..final_length].to_vec()
        } else {
            sifted_key
        };

        session.final_key = final_key.clone();
        session.state = BB84State::KeyEstablished;
        
        // Store the key in the key store
        self.key_store.store_key(session.id, &final_key).await?;
        
        Ok(final_key)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::entropy::SimulatedQuantumSource;
    use crate::key_store::InMemoryKeyStore;
    
    #[tokio::test]
    async fn test_bb84_protocol() {
        let entropy_source = Arc::new(SimulatedQuantumSource::new());
        let key_store = Arc::new(InMemoryKeyStore::new());
        
        let protocol = BB84Protocol::new(entropy_source, key_store);
        
        // Initialize a session
        let mut session = protocol.new_session().await.unwrap();
        assert_eq!(session.state, BB84State::New);
        
        // Generate quantum bits
        let bits = protocol.generate_quantum_bits(&mut session, 100).await.unwrap();
        assert_eq!(bits.len(), 100);
        assert_eq!(session.state, BB84State::BitsTransmitted);
        
        // For testing, we'll simulate another party with same bases
        let other_bases = session.bases.clone();
        
        // Reconcile bases
        let matched = protocol.reconcile_bases(&mut session, &other_bases).await.unwrap();
        assert!(!matched.is_empty());
        assert_eq!(session.state, BB84State::BasesReconciled);
        
        // Test error detection (no errors in this test)
        let sample_indices: Vec<(usize, u8)> = matched.iter()
            .take(10)
            .map(|&idx| (idx, session.raw_bits[idx]))
            .collect();
            
        let error_rate = protocol.detect_errors(&mut session, &sample_indices).await.unwrap();
        assert_eq!(error_rate, 0.0);
        assert_eq!(session.state, BB84State::ErrorDetected);
        
        // Generate final key
        let final_key = protocol.privacy_amplification(&mut session, 32).await.unwrap();
        assert!(!final_key.is_empty());
        assert_eq!(session.state, BB84State::KeyEstablished);
        
        // Check key in store
        let stored_key = protocol.key_store.get_key(session.id).await.unwrap();
        assert_eq!(stored_key.key, final_key);
    }
}
